# Slab Compression Rules

**Receipt Aggregation and Compression**

| Field | Value |
|-------|-------|
| **Module** | 30_ats_runtime |
| **Section** | Slab Compression Rules |
| **Version** | 1.0.1 |
| **Status** | ACTIVE |
| **Revised** | 2026-02-23 |

---

## 1. Overview

Slab compression allows aggregating multiple receipts into a single "slab" for efficient storage and transmission while maintaining verifiability.

---

## 2. Slab Definition

### 2.1 Slab Structure

```json
{
  "slab": {
    "version": "1.0.0",
    "slab_id": "sha256:...",
    "episode_id": "ep001",
    "merkle_root": "sha256:...",
    "micro_receipt_hashes": ["sha256:...", ...],
    "window_start": 1000,
    "window_end": 1100,
    "receipt_count": 100,
    "initial_state_hash": "sha256:...",
    "final_state_hash": "sha256:...",
    "minimal_basis": {
      "B_end_q": 500000000000000000,
      "V_max_q": 1000000000000000,
      "M_max_int": 10000,
      "micro_step_count": 100,
      "retention_policy_id": "policy001"
    }
  }
}
```

### 2.2 Slab Properties

| Property | Description |
|----------|-------------|
| **slab_id** | Content hash of slab (receipt_id style): `sha256:...` |
| **merkle_root** | Merkle root of micro-receipt hashes |
| **micro_receipt_hashes** | List of merkle leaf hashes |
| **minimal_basis** | Minimum info for fraud proof verification |

---

## 3. Minimal Basis

### 3.1 Definition

The **minimal basis** contains the minimum information needed to verify any micro-receipt in the slab without requiring all receipts.

```python
@dataclass
class MinimalBasis:
    B_end_q: int      # FINAL budget (last receipt), NOT max!
    V_max_q: int     # Maximum risk in slab
    M_max_int: int   # Maximum memory in slab
    micro_step_count: int
    retention_policy_id: str
```

### 3.2 CRITICAL: B_end is END, not MAX

> **IMPORTANT**: `B_end_q` is the **final budget value** (budget_after of the last receipt in the slab), NOT the maximum budget.

```
B_end_q = budget_after_q of the LAST micro-receipt in slab
```

Using `max(budget_after_q)` would be incorrect because budget decreases monotonically - the last receipt has the lowest budget.

### 3.3 V_max and M_max are Maxima

```
V_max_q = max(risk_after_q for all receipts in slab)
M_max_int = max(memory_used for all receipts in slab)
```

### 3.4 Minimal Basis Theorem (Formal)

**Theorem**: Under policy Π defined by constraints C1–Ck, the minimal sufficient statistics for slab admissibility are exactly:

```
MinimalBasis = {B_end_q, V_max_q, M_max_int, step_count, policy_id}
```

Where:
- `B_end_q` = final budget (not max)
- `V_max_q` = maximum risk observed
- `M_max_int` = maximum memory used
- `step_count` = number of micro-steps
- `policy_id` = policy identifier

**Observable Algebra**: The admissibility ideal I ⊂ ℝ[ B, V, M ] is generated by:
```
I = ⟨ B - B_end_q, V - V_max_q, M - M_max_int ⟩
```

**Proof Sketch**: For any slab S satisfying policy Π, the tuple above is sufficient to verify any micro-receipt r ∈ S because:
1. Budget trajectory is monotonic decreasing → B_end_q determines all intermediate values
2. Risk is non-increasing → V_max_q bounds all intermediate values
3. Memory is bounded → M_max_int bounds all intermediate values

This is the minimal generating set - removing any component would make verification impossible.

**Q.E.D.**

---

## 4. Merkle Commitment

### 3.1 Allowed Algorithms

| Algorithm | Use Case | Notes |
|-----------|----------|-------|
| **LZ4** | Fast compression | Default for runtime |
| **FLATE** | Max compression | For archival |
| **None** | Small slabs | For debugging |

### 3.2 Compression Format

```
compressed = algorithm(compressed_json_list)
```

Where `compressed_json_list` is:

```json
[
  {"receipt_id": "a1b2c3d4", "chain_digest": "..."},
  {"receipt_id": "e5f6g7h8", "chain_digest": "..."},
  ...
]
```

---

## 4. Verification with Slabs

### 4.1 Slab Verification

```python
def verify_slab(slab: Slab, expected_hash: str) -> bool:
    # Decompress
    receipts = decompress(slab.compressed_receipts)
    
    # Verify count
    if len(receipts) != slab.receipt_count:
        return False
    
    # Verify first/last
    if receipts[0].receipt_id != slab.first_receipt_id:
        return False
    if receipts[-1].receipt_id != slab.last_receipt_id:
        return False
    
    # Verify chain
    if not verify_chain(receipts):
        return False
    
    return True
```

### 4.2 Partial Verification

For large slabs, verify incrementally:

```python
def verify_slab_partial(slab: Slab, sample_size: int) -> bool:
    receipts = decompress(slab.compressed_receipts)
    
    # Verify random sample
    for i in random.sample(range(len(receipts)), sample_size):
        if not verify_receipt(receipts[i]):
            return False
    
    return True
```

---

## 5. Slab Boundaries

### 5.1 When to Create Slabs

| Trigger | Slab Size |
|---------|-----------|
| **Episode End** | All receipts in episode |
| **Size Limit** | 1MB default |
| **Time Limit** | Every 5 minutes |
| **Checkpoint** | Manual trigger |

### 5.2 Slab Metadata

Every slab includes:
- Episode identifier
- Time range
- Receipt count
- State hash range

---

## 6. References

- [Receipt Schema](../20_coh_kernel/receipt_schema.md)
- [Chain Hash Universal](../20_coh_kernel/chain_hash_universal.md)
- [Replay Verification](./replay_verification.md)
