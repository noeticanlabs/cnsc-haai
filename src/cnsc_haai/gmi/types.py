"""
GMI Core Types

Immutable dataclasses for GMI state, actions, and receipts.
All numeric fields are integers (no floats).
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Dict, Any, List


@dataclass(frozen=True)
class GMIState:
    """
    GMI system state.

    All arrays are represented as nested lists of integers (no floats).
    All values are in integer domain for determinism.
    """

    rho: List[List[int]]  # density in [0, rho_max] integer domain
    theta: List[List[int]]  # phase potential integer domain
    C: List[List[int]]  # curvature in [0, +inf) integer domain
    b: int  # budget in QFixed scaled integer
    t: int  # integer time step

    def __post_init__(self):
        """Validate state structure."""
        if not isinstance(self.rho, list) or not self.rho:
            raise ValueError("rho must be non-empty list")
        if not isinstance(self.theta, list) or not self.theta:
            raise ValueError("theta must be non-empty list")
        if not isinstance(self.C, list) or not self.C:
            raise ValueError("C must be non-empty list")


@dataclass(frozen=True)
class GMIAction:
    """
    GMI action - minimal action set for proposing drift.

    Delta fields represent integer domain changes.
    """

    drho: List[List[int]]  # density delta
    dtheta: List[List[int]]  # phase potential delta
    u_glyph: Optional[List[List[int]]] = None  # optional external glyph forcing

    def __post_init__(self):
        """Validate action structure."""
        if not isinstance(self.drho, list) or not self.drho:
            raise ValueError("drho must be non-empty list")
        if not isinstance(self.dtheta, list) or not self.dtheta:
            raise ValueError("dtheta must be non-empty list")


@dataclass(frozen=True)
class GMIStepReceipt:
    """
    GMI step receipt - cryptographic record of state transition.

    Contains all information needed for replay verification and audit.
    """

    version: str
    prev_state_hash: bytes
    next_state_hash: bytes
    chain_prev: bytes
    chain_next: bytes

    V_prev_q: int  # Lyapunov value before step (scaled)
    V_next_q: int  # Lyapunov value after step (scaled)
    dV_q: int  # Delta V (scaled)

    b_prev_q: int  # Budget before step (scaled)
    b_next_q: int  # Budget after step (scaled)
    db_q: int  # Budget delta (scaled)

    projected: bool  # Whether projection was applied
    reject_code: Optional[str]  # None if accepted, else rejection reason
    witness: Dict[str, Any]  # Active sets, multipliers, norms

    def is_accepted(self) -> bool:
        """Check if step was accepted."""
        return self.reject_code is None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "version": self.version,
            "prev_state_hash": self.prev_state_hash.hex(),
            "next_state_hash": self.next_state_hash.hex(),
            "chain_prev": self.chain_prev.hex(),
            "chain_next": self.chain_next.hex(),
            "V_prev_q": self.V_prev_q,
            "V_next_q": self.V_next_q,
            "dV_q": self.dV_q,
            "b_prev_q": self.b_prev_q,
            "b_next_q": self.b_next_q,
            "db_q": self.db_q,
            "projected": self.projected,
            "reject_code": self.reject_code,
            "witness": self.witness,
        }


# =============================================================================
# Runtime Types (v1.6)
# =============================================================================


@dataclass(frozen=True)
class Proposal:
    """
    A single proposal from the predictor/NPE.

    Proposals are generated by the predictor and evaluated by gates.
    """

    proposal_id: str  # Unique identifier
    action: GMIAction  # The proposed action
    score: int  # Proposal score (higher = better)
    metadata: Dict[str, Any]  # Additional proposal metadata


@dataclass(frozen=True)
class ProposalSet:
    """
    A set of proposals from the predictor.

    This is stored with a Merkle root for deterministic receipt.
    """

    proposals: List[Proposal]
    seed: int  # PRNG seed for reproducibility
    timestamp: int  # Generation timestamp (integer)

    def __len__(self) -> int:
        return len(self.proposals)


@dataclass(frozen=True)
class GateDecision:
    """
    Result of gate evaluation on a proposal.
    """

    gate_id: str
    passed: bool
    reason: Optional[str] = None
    witness: Dict[str, Any] = None


@dataclass(frozen=True)
class WorkUnits:
    """
    Metabolic budget: work units spent per tick.

    Tracks actual computational work for budget enforcement.
    """

    proposal_generation_cost: int = 0  # NPE compute
    witness_acquisition_cost: int = 0  # Evidence gathering
    gate_evaluation_cost: int = 0  # Policy checks
    execution_cost: int = 0  # State update
    memory_write_cost: int = 0  # Receipt storage
    repair_cost: int = 0  # Corrections applied

    def total(self) -> int:
        """Total work units spent."""
        return (
            self.proposal_generation_cost
            + self.witness_acquisition_cost
            + self.gate_evaluation_cost
            + self.execution_cost
            + self.memory_write_cost
            + self.repair_cost
        )


@dataclass(frozen=True)
class GMIRuntimeReceipt:
    """
    Complete runtime receipt for a GMI tick.

    Includes step receipt, proposal info, gate decisions, and work costs.
    """

    step_receipt: GMIStepReceipt  # Core GMI step receipt
    proposal_set_root: Optional[bytes]  # Merkle root of proposals (None if no proposals)
    proposal_count: int  # Number of proposals evaluated
    selected_proposal_id: Optional[str]  # ID of selected proposal
    gate_decisions: List[GateDecision]  # Per-gate results
    work_units: WorkUnits  # Metabolic work spent
    total_work_q: int  # Total work in QFixed

    def is_accepted(self) -> bool:
        """Check if tick was accepted."""
        return self.step_receipt.is_accepted()

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "step_receipt": self.step_receipt.to_dict(),
            "proposal_set_root": self.proposal_set_root.hex() if self.proposal_set_root else None,
            "proposal_count": self.proposal_count,
            "selected_proposal_id": self.selected_proposal_id,
            "gate_decisions": [
                {
                    "gate_id": d.gate_id,
                    "passed": d.passed,
                    "reason": d.reason,
                    "witness": d.witness,
                }
                for d in self.gate_decisions
            ],
            "work_units": {
                "proposal_generation_cost": self.work_units.proposal_generation_cost,
                "witness_acquisition_cost": self.work_units.witness_acquisition_cost,
                "gate_evaluation_cost": self.work_units.gate_evaluation_cost,
                "execution_cost": self.work_units.execution_cost,
                "memory_write_cost": self.work_units.memory_write_cost,
                "repair_cost": self.work_units.repair_cost,
            },
            "total_work_q": self.total_work_q,
        }
